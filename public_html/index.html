<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - cloth simulation</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link type="text/css" rel="stylesheet" href="main.css">
        <style>
            body {
                background-color: #000;
                color: #fff;
            }
            a {
                color: #080;
            }
        </style>
    </head>

    <body>
        <script type="module">

            import * as THREE from './js/three/build/three.module.js';

            import Stats from './js/three/examples/jsm/libs/stats.module.js';
            import { GUI } from './js/three/examples/jsm/libs/dat.gui.module.js';

            import { OrbitControls } from './js/three/examples/jsm/controls/OrbitControls.js';

            /*
             * Cloth Simulation using a relaxed constraints solver
             */

            // Suggested Readings
            // Advanced Character Physics by Thomas Jakobsen Character
            // http://freespace.virgin.net/hugo.elias/models/m_cloth.htm
            // http://en.wikipedia.org/wiki/Cloth_modeling
            // http://cg.alexandra.dk/tag/spring-mass-system/
            // Real-time Cloth Animation http://www.darwin3d.com/gamedev/articles/col0599.pdf


            const wind_p = {
                DAMPING: 0.03,
                DRAG: 1 - 0.03, //1 - DAMPING
                MASS: 0.1,
                restDistance: 25,
                xSegs: 10,
                ySegs: 15,
                GRAVITY: 981 * 1.4,
                windForce: new THREE.Vector3(0, 0, 0),
                tmpForce: new THREE.Vector3()
            };

            const windEnabled = true;
            const TIMESTEP = 18 / 1000;
            const TIMESTEP_SQ = TIMESTEP * TIMESTEP;
            const pins = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

            const clothFunction = plane(wind_p.restDistance * wind_p.xSegs, wind_p.restDistance * wind_p.ySegs);

            const cloth = new Cloth(wind_p.xSegs, wind_p.ySegs);

            // (up/-down,left/-right,front/-back)
            const gravity = new THREE.Vector3(0, -wind_p.GRAVITY, 0).multiplyScalar(wind_p.MASS);

            function plane(width, height) {
                return function (u, v, target) {
                    const x = (u - 0.5) * width;
                    const y = (v + 0.5) * height;
                    const z = 0;
                    target.set(x, y, z);
                };
            }

            function Particle(x, y, z, mass) {
                this.position = new THREE.Vector3();
                this.previous = new THREE.Vector3();
                this.original = new THREE.Vector3();
                this.a = new THREE.Vector3(0, 0, 0); // acceleration
                this.mass = mass;
                this.invMass = 1 / mass;
                this.tmp = new THREE.Vector3();
                this.tmp2 = new THREE.Vector3();
                // init
                clothFunction(x, y, this.position); // position
                clothFunction(x, y, this.previous); // previous
                clothFunction(x, y, this.original);
            }

            // Force -> Acceleration

            Particle.prototype.addForce = function (force) {
                this.a.add(
                        this.tmp2.copy(force).multiplyScalar(this.invMass)
                        );
            };


            // Performs Verlet integration

            Particle.prototype.integrate = function (timesq) {

                const newPos = this.tmp.subVectors(this.position, this.previous);
                newPos.multiplyScalar(wind_p.DRAG).add(this.position);
                newPos.add(this.a.multiplyScalar(timesq));

                this.tmp = this.previous;
                this.previous = this.position;
                this.position = newPos;
                
                this.a.set(0, 0, 0);
            };


            const diff = new THREE.Vector3();

            function satisfyConstraints(p1, p2, distance) {

                diff.subVectors(p2.position, p1.position);
                const currentDist = diff.length();
                if (currentDist === 0)
                    return; // prevents division by 0
                const correction = diff.multiplyScalar(1 - distance / currentDist);
                const correctionHalf = correction.multiplyScalar(0.5);
                p1.position.add(correctionHalf);
                p2.position.sub(correctionHalf);
            }


            function Cloth(w, h) {

                w = w || 10;
                h = h || 10;
                this.w = w;
                this.h = h;

                const particles = [];
                const constraints = [];

                // Create particles
                for (let v = 0; v <= h; v++) {
                    for (let u = 0; u <= w; u++) {
                        particles.push(
                                new Particle(u / w, v / h, 0, wind_p.MASS)
                                );
                    }
                }

                // Structural
                for (let v = 0; v < h; v++) {
                    for (let u = 0; u < w; u++) {
                        constraints.push([
                            particles[ index(u, v) ],
                            particles[ index(u, v + 1) ],
                            wind_p.restDistance
                        ]);
                        constraints.push([
                            particles[ index(u, v) ],
                            particles[ index(u + 1, v) ],
                            wind_p.restDistance
                        ]);
                    }
                }

                for (let u = w, v = 0; v < h; v++) {
                    constraints.push([
                        particles[ index(u, v) ],
                        particles[ index(u, v + 1) ],
                        wind_p.restDistance

                    ]);
                }

                for (let v = h, u = 0; u < w; u++) {
                    constraints.push([
                        particles[ index(u, v) ],
                        particles[ index(u + 1, v) ],
                        wind_p.restDistance
                    ]);
                }

                this.particles = particles;
                this.constraints = constraints;

                function index(u, v) {
                    return u + v * (w + 1);
                }
                this.index = index;
            }

            function simulate(now) {

                const windStrength = Math.cos(now / 7000) * 20 + 40;

                wind_p.windForce.set(Math.sin(now / 2000), Math.cos(now / 3000), Math.sin(now / 1000));
                wind_p.windForce.normalize();
                wind_p.windForce.multiplyScalar(windStrength);

                // Aerodynamics forces
                const particles = cloth.particles;

                if (windEnabled) {
                    let indx;
                    const normal = new THREE.Vector3();
                    const indices = clothGeometry.index;
                    const normals = clothGeometry.attributes.normal;

                    for (let i = 0, il = indices.count; i < il; i += 3) {
                        for (let j = 0; j < 3; j++) {
                            indx = indices.getX(i + j);
                            normal.fromBufferAttribute(normals, indx);
                            wind_p.tmpForce.copy(normal).normalize().multiplyScalar(normal.dot(wind_p.windForce));
                            particles[ indx ].addForce(wind_p.tmpForce);

                        }
                    }
                }

                for (let i = 0, il = particles.length; i < il; i++) {
                    const particle = particles[ i ];
                    particle.addForce(gravity);
                    particle.integrate(TIMESTEP_SQ);
                }

                // Start Constraints
                const constraints = cloth.constraints;
                const il = constraints.length;

                for (let i = 0; i < il; i++) {

                    const constraint = constraints[ i ];
                    satisfyConstraints(constraint[ 0 ], constraint[ 1 ], constraint[ 2 ]);

                }

                // Floor Constraints
                for (let i = 0, il = particles.length; i < il; i++) {
                    const particle = particles[ i ];
                    const pos = particle.position;
                    if (pos.y < -250) {
                        pos.y = -250;
                    }
                }

                // Pin Constraints
                for (let i = 0, il = pins.length; i < il; i++) {
                    const xy = pins[ i ];
                    const p = particles[ xy ];
                    p.position.copy(p.original);
                    p.previous.copy(p.original);
                }
            }

            let container, stats;
            let camera, scene, renderer;

            let clothGeometry;
            let sphere;
            let flagMesh;
            let flagPoleMesh;
            let flagPoleTopMesh;

            init();
            animate(0);

            function init() {

                container = document.createElement('div');
                container.setAttribute('id', 'main_view');
                document.body.appendChild(container);

                // scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x07074d);
                scene.fog = new THREE.Fog(0x07074d, 500, 10000);

                // camera
                camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 10000);
                camera.position.set(1000, -100, 3000);
                camera.lookAt(new THREE.Vector3(0, 0, 0));

                // lights
                const light = new THREE.DirectionalLight(0xdfebff, 1);
                light.position.set(-150, 550, 1000);
                light.position.multiplyScalar(1.3);
                light.castShadow = true;
                light.shadow.mapSize.width = 1024;
                light.shadow.mapSize.height = 1024;
                const d = 2000;
                light.shadow.camera.left = -d;
                light.shadow.camera.right = d;
                light.shadow.camera.top = d;
                light.shadow.camera.bottom = -d;
                light.shadow.camera.far = 3000;
                scene.add(light);


                // start flag
                // cloth material
                const loader = new THREE.TextureLoader();

                const clothTexture = loader.load('textures/flag_pattern.png');
                clothTexture.anisotropy = 16;

                const clothMaterial = new THREE.MeshLambertMaterial({
                    map: clothTexture,
                    side: THREE.DoubleSide,
                    alphaTest: 0
                });

                // cloth geometry is passed to the wind machine
                clothGeometry = new THREE.ParametricBufferGeometry(clothFunction, cloth.w, cloth.h);
                // cloth mesh
                flagMesh = new THREE.Mesh(clothGeometry, clothMaterial);
                flagMesh.position.set(0, 350, 0);
                flagMesh.castShadow = true;
                flagMesh.rotation.z = Math.PI / 2;
                scene.add(flagMesh);
                // gives it the light depth variations
                flagMesh.customDepthMaterial = new THREE.MeshDepthMaterial({
                    depthPacking: THREE.RGBADepthPacking,
                    map: clothTexture,
                    alphaTest: 0
                });
                // end flag

                // ground
                const groundTexture = loader.load('./textures/grasslight-big.jpg');
                groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
                groundTexture.repeat.set(25, 25);
                groundTexture.anisotropy = 16;
                groundTexture.encoding = THREE.sRGBEncoding;
                const groundMaterial = new THREE.MeshLambertMaterial({map: groundTexture});
                let mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(20000, 20000), groundMaterial);
                mesh.position.y = -250;
                mesh.rotation.x = -Math.PI / 2;
                mesh.receiveShadow = true;
                scene.add(mesh);

                // flag pole and parts
                // flag pole
                const reflectiveMat = new THREE.MeshStandardMaterial({color: 0x333333, roughness: 0.1, metalness: 1.0});
                // pole
                const poleGeo = new THREE.CylinderBufferGeometry(10, 10, 750, 10);
                flagPoleMesh = new THREE.Mesh(poleGeo, reflectiveMat);
                flagPoleMesh.position.x = -200;
                flagPoleMesh.position.y = 125;
                flagPoleMesh.receiveShadow = true;
                flagPoleMesh.castShadow = true;
                scene.add(flagPoleMesh);
                // round top
                const poleTopGeo = new THREE.SphereGeometry(15, 16, 16);
                flagPoleTopMesh = new THREE.Mesh(poleTopGeo, reflectiveMat);
                flagPoleTopMesh.position.x = -200;
                flagPoleTopMesh.position.y = 500;
                flagPoleTopMesh.receiveShadow = true;
                flagPoleTopMesh.castShadow = true;
                scene.add(flagPoleTopMesh);
                // end flag pole and parts

                // renderer
                renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.outputEncoding = THREE.sRGBEncoding;
                renderer.shadowMap.enabled = true;

                container.appendChild(renderer.domElement);

                // controls
                const controls = new OrbitControls(camera, renderer.domElement);
                controls.maxPolarAngle = Math.PI;
                controls.minDistance = 1000;
                controls.maxDistance = 5000;

                // performance monitor
                stats = new Stats();
                container.appendChild(stats.dom);

                // 38 up
                // 40 down
                // 37 left
                // 39 right
                // for finding positions
                let keyDownTextField = function (e) {
                    // turn off
                    //return;
                    let diff = 50;
                    let m_now = island;
                    switch (e.keyCode) {
                        case 87:
                            console.log('up');
                            m_now.position.y += diff;
                            console.log('y is ' + m_now.position.y);
                            break;
                        case 83:
                            console.log('down');
                            m_now.position.y -= diff;
                            console.log('y is ' + m_now.position.y);
                            break;
                        case 65:
                            console.log('left');
                            m_now.position.x -= diff;
                            console.log('x is ' + m_now.position.x);
                            break;
                        case 68:
                            console.log('right');
                            m_now.position.x += diff;
                            console.log('x is ' + m_now.position.x);
                            break;
                    }
                };

                //
                window.addEventListener('resize', onWindowResize, false);
                document.body.addEventListener("keydown", keyDownTextField, false);
            }

            // resize updates
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            // Disneyfy
            function animate(now) {
                requestAnimationFrame(animate);
                simulate(now);
                render();
                stats.update();
            }

            function render() {
                const p = cloth.particles;
                for (let i = 0, il = p.length; i < il; i++) {
                    const v = p[ i ].position;
                    clothGeometry.attributes.position.setXYZ(i, v.x, v.y, v.z);
                }
                clothGeometry.attributes.position.needsUpdate = true;
                clothGeometry.computeVertexNormals();
                renderer.render(scene, camera);
            }

        </script>
    </body>
</html>