<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - cloth simulation</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link type="text/css" rel="stylesheet" href="main.css">
        <style>
            body {
                background-color: #000;
                color: #fff;
            }
            a {
                color: #080;
            }
        </style>
    </head>

    <body>
        <script type="module">

            import * as THREE from './js/three/build/three.module.min.js';
            import Stats from './js/three/examples/jsm/libs/stats.module.js';
            import { OrbitControls } from './js/three/examples/jsm/controls/OrbitControls.js';

            import{ Cloth } from './js/WindMachine.js';

            /*
             * Cloth Simulation using a relaxed constraints solver
             */

            // Suggested Readings
            // Advanced Character Physics by Thomas Jakobsen Character
            // http://freespace.virgin.net/hugo.elias/models/m_cloth.htm
            // http://en.wikipedia.org/wiki/Cloth_modeling
            // http://cg.alexandra.dk/tag/spring-mass-system/
            // Real-time Cloth Animation http://www.darwin3d.com/gamedev/articles/col0599.pdf


            const wind_params = {
                DAMPING: 0.03,
                DRAG: 1 - 0.03, //1 - DAMPING
                MASS: 0.1,
                restDistance: 25,
                xSegs: 10,
                ySegs: 15,
                GRAVITY: 981 * 1.4, // reasons unknown
                windForce: new THREE.Vector3(0, 0, 0),
                tmpForce: new THREE.Vector3(),
                windEnabled: true,
                TIMESTEP: 18 / 1000,
                TIMESTEP_SQ: (18 / 1000) * (18 / 1000)
            };

            const cloth = new Cloth(wind_params);

            let container, stats;
            let camera, scene, renderer;

            let sphere;
            let flagMesh;
            let flagPoleMesh;
            let flagPoleTopMesh;

            init();
            animate(0);

            function init() {

                container = document.createElement('div');
                container.setAttribute('id', 'main_view');
                document.body.appendChild(container);

                // scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x07074d);
                scene.fog = new THREE.Fog(0x07074d, 500, 10000);

                // camera
                camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 10000);
                camera.position.set(1000, -100, 3000);
                camera.lookAt(new THREE.Vector3(0, 0, 0));

                // lights
                // DirectionalLight makes far better shadows than SpotLight
                const light = new THREE.DirectionalLight(0xdfebff, 1);
                light.position.set(-150, 550, 1000);
                light.position.multiplyScalar(1.3);
                light.castShadow = true;
                light.shadow.mapSize.width = 1024;
                light.shadow.mapSize.height = 1024;
                const d = 2000;
                light.shadow.camera.left = -d;
                light.shadow.camera.right = d;
                light.shadow.camera.top = d;
                light.shadow.camera.bottom = -d;
                light.shadow.camera.far = 3000;
                scene.add(light);


                // start flag
                // cloth material
                const loader = new THREE.TextureLoader();

                const clothTexture = loader.load('textures/flag_pattern.png');
                clothTexture.anisotropy = 16;

                const clothMaterial = new THREE.MeshLambertMaterial({
                    map: clothTexture,
                    side: THREE.DoubleSide,
                    alphaTest: 0
                });

                // cloth mesh
                flagMesh = new THREE.Mesh(cloth.geometry, clothMaterial);
                flagMesh.position.set(0, 350, 0);
                flagMesh.castShadow = true;
                flagMesh.rotation.z = Math.PI / 2;
                scene.add(flagMesh);
                // gives it the light depth variations
                flagMesh.customDepthMaterial = new THREE.MeshDepthMaterial({
                    depthPacking: THREE.RGBADepthPacking,
                    map: clothTexture,
                    alphaTest: 0
                });
                // end flag

                // ground
                const groundTexture = loader.load('./textures/grasslight-big.jpg');
                groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
                groundTexture.repeat.set(25, 25);
                groundTexture.anisotropy = 16;
                groundTexture.encoding = THREE.sRGBEncoding;
                const groundMaterial = new THREE.MeshLambertMaterial({map: groundTexture});
                let mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(20000, 20000), groundMaterial);
                mesh.position.y = -250;
                mesh.rotation.x = -Math.PI / 2;
                mesh.receiveShadow = true;
                scene.add(mesh);

                // flag pole and parts
                // flag pole
                const reflectiveMat = new THREE.MeshStandardMaterial({color: 0x333333, roughness: 0.1, metalness: 1.0});
                // pole
                const poleGeo = new THREE.CylinderBufferGeometry(10, 10, 750, 10);
                flagPoleMesh = new THREE.Mesh(poleGeo, reflectiveMat);
                flagPoleMesh.position.x = -200;
                flagPoleMesh.position.y = 125;
                flagPoleMesh.receiveShadow = true;
                flagPoleMesh.castShadow = true;
                scene.add(flagPoleMesh);
                // round top
                const poleTopGeo = new THREE.SphereGeometry(15, 16, 16);
                flagPoleTopMesh = new THREE.Mesh(poleTopGeo, reflectiveMat);
                flagPoleTopMesh.position.x = -200;
                flagPoleTopMesh.position.y = 500;
                flagPoleTopMesh.receiveShadow = true;
                flagPoleTopMesh.castShadow = true;
                scene.add(flagPoleTopMesh);
                // end flag pole and parts

                // renderer
                renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.outputEncoding = THREE.sRGBEncoding;
                renderer.shadowMap.enabled = true;

                container.appendChild(renderer.domElement);

                // controls
                const controls = new OrbitControls(camera, renderer.domElement);
                controls.maxPolarAngle = Math.PI;
                controls.minDistance = 1000;
                controls.maxDistance = 5000;

                // performance monitor
                stats = new Stats();
                container.appendChild(stats.dom);

                // 38 up
                // 40 down
                // 37 left
                // 39 right
                // for finding positions
                let keyDownTextField = function (e) {
                    // turn off
                    //return;
                    let change = 50;
                    let m_now = flagPoleMesh;
                    switch (e.keyCode) {
                        case 87:
                            console.log('up');
                            m_now.position.y += change;
                            console.log('y is ' + m_now.position.y);
                            break;
                        case 83:
                            console.log('down');
                            m_now.position.y -= change;
                            console.log('y is ' + m_now.position.y);
                            break;
                        case 65:
                            console.log('left');
                            m_now.position.x -= change;
                            console.log('x is ' + m_now.position.x);
                            break;
                        case 68:
                            console.log('right');
                            m_now.position.x += change;
                            console.log('x is ' + m_now.position.x);
                            break;
                    }
                };

                //
                window.addEventListener('resize', onWindowResize, false);
                document.body.addEventListener("keydown", keyDownTextField, false);
            }

            // resize updates
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            // Disneyfy
            function animate(now) {
                requestAnimationFrame(animate);
                cloth.simulate(now);
                render();
                stats.update();
            }

            function render() {
                const p = cloth.particles;
                for (let i = 0, il = p.length; i < il; i++) {
                    const v = p[ i ].position;
                    cloth.geometry.attributes.position.setXYZ(i, v.x, v.y, v.z);
                }
                cloth.geometry.attributes.position.needsUpdate = true;
                cloth.geometry.computeVertexNormals();
                renderer.render(scene, camera);
            }

        </script>
    </body>
</html>